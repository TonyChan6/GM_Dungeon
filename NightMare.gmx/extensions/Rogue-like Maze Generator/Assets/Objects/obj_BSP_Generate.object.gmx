<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// This is our controller object and should be placed in any room where we 
// want to generate our random map. It creates a ds_grid that is populated 
// with the following values:
/*

-4          - Empty grid cell (ie: "floor")
0 - 99      - A "room" number within the grid that hasn't been assigned
100         - A "wall" for a room area
150         - The outer "wall" of the whole room
200         - A "corridor" between rooms
300 - 301   - A "door" into a room area. 300 = horizontal door, 301 = vertical door
500 - 1000  - The pathfinder start points for making corridors

*/
// The grid created can then be parsed and the appropriate object created
// based on the return value for each grid cell.

// These scripts work by repeatedly splitting a GMS room into smaller and smaller 
// grid sections. They then create a "room" area within each section of the grid 
// which are joined together using "corridors". The number of room areas created
// will largely depend on the size of the actual room in GameMaker as well as
// the number of splits that you assign and the size of the base tile to use.

// NOTE: You can give large numbers for the splits to achieve and the scripts 
// will TRY to create them, but may not succeed if the split size is too small



// Create some initial vars to control basic size and form of the rooms/grid
// NOTE: The global vars here are from the DEMO init object, but can be replaced 
// with real numbers or constants etc... as your game requires.

var split_width_min = global.splitSize;  // The minimum size of each "room" in the map (minimum value = 3)
var split_skip_num = global.roomSkip;    // Rooms can be skipped, creating empty spaces in the map
var split_num = global.splitNum;         // The number of slpits that the scripts should TRY to create


// Create the BSP ds_grid (Note the global variable! As with above, you can use
// a real or other value here as the global is only added for convenience in this demo

bsp_grid = scr_BSP_Create(global.tileSize, split_num);


// Split the room and populate the grid with the initial areas for the map

scr_BSP_Split_Room(bsp_grid, split_width_min, split_num);


// Parse the room grid and generate "rooms" within each split area
// if you have chosen a value for rooms to skip, then you MAY have empty areas 
// within the map, but not always, as the scripts adapt to always have a minimum 
// number of rooms (2) to prevent errors. The script returns the number of rooms
// that have been created which is required in future scripts.

// The script will also generate an array r[a, b], where [a] is the room number 
// and [b] is the x, y, width, and height. So, for example, to get the grid 
// center of the first room area generated we could do the following:

/*
var xx = r[0, 0];
var yy = r[0, 1];
var ww = r[0, 2];
var hh = r[0, 3];
var xpos = xx + (ww div 2);
var ypos = yy + (hh div 2);
instance_create(xx * tile_size, yy * tile_size, OBJECT);
*/

// this is VERY IMPORTANT as it permits you to then use the scr_BSP_Create_Object
// script to create your own objects anywhere within the map and be sure that 
// they are inside a room.

var count = scr_BSP_Create_Room_Space(bsp_grid, split_skip_num, split_width_min);


// This script creates the "wall" spaces around the rooms in the map.

scr_BSP_Create_Internal_Walls(bsp_grid, count, tile_size);


// This script uses pathfinding to create "corridors" between rooms

scr_BSP_Create_Corridors(bsp_grid, tile_size, count);


// This script is for cleaning up. It is commented out since for the demo/example
// we don't want to destroy it yet as it's being drawn to the screen, but when not 
// debugging it can be uncommented (it is currently used in the Room End event)

// scr_BSP_Clear(bsp_grid);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Clear the grid on room end. You would normally do this at the 
// end of the room generation code in the Create Event, but for this 
// demo we have it here to permit the debug drawing to work.

scr_BSP_Clear(bsp_grid);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// For debugging there is a debug script supplied.
// If you are happy that the scripts work in your game as they
// should then you can remove this as well as the debug code in 
// the script scr_BSP_Create().

scr_BSP_Draw_Debug(bsp_grid, tile_size);

//This is extra info for the DEMO only and can be removed
draw_set_colour(c_black);
draw_set_alpha(0.5);
draw_rectangle(0, 0, 256, 96, false);
draw_set_alpha(1);
draw_set_colour(c_white);
draw_set_halign(fa_left);
draw_text(8, 16, "MAZE GENERATED!#Press &lt;SPACE&gt; ro regenerate#Press &lt;ENTER&gt; to go to the initial room again");
draw_set_colour(c_black);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// This code is ONLY for the demo and can be removed

// Restart the room to regenerate a new map
room_restart();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// This code is ONLY for the demo and can be removed.

window_set_size(1024, 768);
surface_resize(application_surface, 1024, 768);
room_goto(rm_Init);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
